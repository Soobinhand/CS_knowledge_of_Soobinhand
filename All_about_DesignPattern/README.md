# 목차
- [DesignPattern](#designpattern)

<br>

## DesignPattern
> - #### 정의
>   - 각 패턴은 소프트웨어 개발 시 지속적으로 발생할 수 있는 문제를 두 번 반복하지 않을 수 있도록 그 문제에 대한 해결책의 핵심입니다.
>   - 재사용 가능한 문제 해결 방법, 즉 전문가들이 만들어놓은 문제 설명과 해결 방법이며 재사용성이 높습니다.

<br>

## 디자인 패턴 분류
> - #### 생성 패턴
>   - *객체의 생성 과정과 연관된 패턴입니다.*   
>   - 추상 팩토리(Abstract Factory)
>   - 빌더(Builder)
>   - 팩토리 메소드(Factory Method)
>   - 프로토타입(Prototype)
>   - 싱글톤(Singleton)
> - #### 구조 패턴
>   - *클래스나 객체의 합성/집합에 관련된 패턴입니다.*
>   - 어댑터(Adapter)
>   - 브리지(Bridge)
>   - 컴포지트(Composite)
>   - 데코레이터(Decorator)
>   - 퍼사드(Facade)
>   - 플라이웨이트(Flyweight)
>   - 프록시(Proxy)
> - #### 행위 패턴
>   - *클래스나 객체들이 상호작용하는 방법과 책임을 분산시키는 방법을 정의하는 패턴입니다.*
>   - 책임 연쇄(Chain of Responsibility)
>   - 커맨드(Command)
>   - 인터프리터(Interpreter)
>   - 반복자(Iterator)
>   - 미디에이터(Mediator)
>   - 메멘토(Memento)
>   - 옵저버(Observer)
>   - 스테이트(State)
>   - 스트래티지(Strategy)
>   - 템플릿 메서드(Template Method)
>   - 비지터(Visitor)
> #### 아래에 각 패턴에 대한 설명이 나와있습니다.

<br>

## SOLID 원칙
> - #### SRP
>   - Single Responsibility Principle
>   - 단일 책임 원칙
>   - 클래스에 기능이 너무 많으면 유지 보수가 어렵기 때문에, 하나의 클래스는 하나의 역할만으로 구성되어있어야 한다는 원칙입니다.
> - #### OCP
>   - Open Closed Principle
>   - 개방 폐쇄 원칙
>   - 기존 코드를 변경하지 않고 확장할 수 있도록 설계해야한다는 원칙입니다.
>   - 변경되지 않을 부분과 변경될 부분을 분리하는 것입니다.
> - #### LSP
>   - Liskov Substitution Principle
>   - 리스코프 치환 원칙
>   - 자식 클래스가 부모 클래스를 대체할 수 있어야한다는 원칙입니다.
>   - 부모 클래스 객체 대신 자식 클래스 객체를 사용했을 때 문제 없이 프로그램이 동작해야함을 의미합니다.
> - #### ISP
>   - Interface Segregation Principle
>   - 인터페이스 분리 원칙
>   - 여러 개 클라이언트에 필요한 기능을 가지고 있는 일반화된 인터페이스보다는 각 클라이언트에 특화되어 있는 인터페이스를 사용해야한다는 원칙입니다.
> - #### DIP
>   - Dependency Inversion Principle
>   - 의존 역전 원칙
>   - 가능하면 추상 클래스나 인터페이스를 사용하자는 원칙입니다.
>   - 추상 클래스나 인터페이스를 정하고 그것을 사용하는 형태로 구현합니다.

<br>

## Strategy Pattern
> - #### 기존 문제점
>   - 클라이언트에 모든 알고리즘을 포함시키는 것은 코드의 양이 늘어나고 복잡해지므로 유지 보수가 어렵습니다.
>   - 모든 알고리즘이 동시에 사용되는 것이 아니면 굳이 함께 넣어야 할 필요가 없습니다.
>   - 알고리즘의 실행 시점에 결정되어서 조건문 등을 이용해서 다른 알고리즘을 선택하는 경우
>   - **OCP 위반**    
> - #### 해결방안
>   - 중복을 공통화시키고, 실행 시점에 맞는 알고리즘을 호출하도록 합니다.
>   - 상속 또는 인터페이스를 많이 활용합니다.
> - #### 목적
>   - 같은 종류의 작업을 하는 알고리즘을 정의, 각 알고리즘을 캡슐화, 그리고 알고리즘들을 서로 바꿔 사용할 수 있도록 합니다.
>   - 이 패턴은 알고리즘을 사용하는 클라이언트로부터 독립적으로 알고리즘을 바꿔서 적용시킬 수 있도록 합니다.
> 